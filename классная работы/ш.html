<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<title>Arena Defender — мини-игра</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  :root{
    --bg:#0b1220;
    --panel: rgba(255,255,255,0.06);
    --accent:#14b8a6;
    --danger:#ff5252;
    --muted: rgba(255,255,255,0.6);
  }
  html,body{height:100%;margin:0;background:linear-gradient(180deg,var(--bg),#07101a);font-family:Inter,system-ui,Arial;}
  .wrap{display:flex;gap:12px;align-items:flex-start;padding:12px;box-sizing:border-box;}
  canvas{background:#07111a;border-radius:8px;box-shadow:0 10px 30px rgba(2,6,23,0.8);display:block;}
  .ui{
    width:320px;
    color:#e6eef3;
    display:flex;
    flex-direction:column;
    gap:12px;
  }
  .panel{
    background:var(--panel);
    padding:12px;border-radius:10px;backdrop-filter: blur(6px);
    box-shadow: inset 0 1px 0 rgba(255,255,255,0.02);
  }
  h1{margin:0;font-size:18px;color:var(--accent)}
  .stat{font-weight:700;font-size:20px}
  .muted{color:var(--muted);font-size:13px}
  .buttons{display:flex;gap:8px;flex-wrap:wrap}
  button{background:linear-gradient(180deg,#1f2937,#111827);border:1px solid rgba(255,255,255,0.03);color:#fff;padding:8px 10px;border-radius:8px;cursor:pointer}
  button.secondary{background:#0b6b73}
  .shop-item{display:flex;justify-content:space-between;align-items:center;padding:8px;border-radius:8px;background:rgba(255,255,255,0.02)}
  .bar{height:10px;background:rgba(255,255,255,0.06);border-radius:8px;overflow:hidden}
  .bar > i{display:block;height:100%;background:linear-gradient(90deg,var(--accent),#7de3d1)}
  .center{display:flex;justify-content:center;align-items:center}
  .footer{font-size:12px;color:var(--muted)}
  .big-btn{padding:10px 14px;font-weight:700;border-radius:10px}
  @media(max-width:900px){
    .wrap{flex-direction:column;align-items:center}
    .ui{width:100%;max-width:420px}
  }
</style>
</head>
<body>
<div class="wrap center">
  <canvas id="game" width="960" height="640"></canvas>

  <div class="ui">
    <div class="panel">
      <h1>Arena Defender</h1>
      <div style="display:flex;justify-content:space-between;align-items:center;margin-top:8px">
        <div>
          <div class="muted">Счёт</div>
          <div class="stat" id="score">0</div>
        </div>
        <div>
          <div class="muted">Волна</div>
          <div class="stat" id="wave">0</div>
        </div>
      </div>
      <div style="margin-top:10px">
        <div class="muted">Здоровье</div>
        <div class="bar" style="margin-top:6px"><i id="hpbar" style="width:100%"></i></div>
      </div>
      <div style="margin-top:10px;display:flex;gap:8px">
        <button id="startBtn" class="big-btn">Старт / Перезапуск</button>
        <button id="pauseBtn" class="big-btn secondary">Пауза</button>
      </div>
      <div style="margin-top:10px" class="muted">Управление: WASD / стрелки — движение; мышь — прицел; клик — стрелять. На тач: джойстик по экрану.</div>
    </div>

    <div class="panel">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div><strong>Магазин</strong><div class="muted">трать очки на апгрейды</div></div>
        <div class="muted">Твои очки: <span id="coins">0</span></div>
      </div>
      <div style="margin-top:8px;display:flex;flex-direction:column;gap:8px">
        <div class="shop-item">
          <div>
            <div><strong>+ Пулевой урон</strong></div>
            <div class="muted">Увеличивает урон выстрела</div>
          </div>
          <div>
            <div style="display:flex;flex-direction:column;align-items:flex-end">
              <div class="muted">Цена: <span id="priceDmg">50</span></div>
              <button id="buyDmg">Купить</button>
            </div>
          </div>
        </div>

        <div class="shop-item">
          <div>
            <div><strong>Скорострельность</strong></div>
            <div class="muted">Уменьшает время между выстрелами</div>
          </div>
          <div>
            <div class="muted">Цена: <span id="priceFire">80</span></div>
            <button id="buyFire">Купить</button>
          </div>
        </div>

        <div class="shop-item">
          <div>
            <div><strong>Здоровье +20</strong></div>
            <div class="muted">Восстановление HP</div>
          </div>
          <div>
            <div class="muted">Цена: <span id="priceHeal">40</span></div>
            <button id="buyHeal">Купить</button>
          </div>
        </div>
      </div>
    </div>

    <div class="panel">
      <div style="display:flex;justify-content:space-between"><div><strong>Статистика</strong></div><div class="muted">Лучший: <span id="hs">0</span></div></div>
      <div style="margin-top:8px">
        <div class="muted">Убийств: <span id="kills">0</span></div>
        <div class="muted">Время: <span id="time">0s</span></div>
      </div>
    </div>

    <div class="panel footer">
      <div class="muted">Версия: 1.0 — Быстрая мини-игра</div>
      <div style="margin-top:6px" class="muted">Советы: собирай очки, покупай апгрейды и выживай как можно дольше.</div>
    </div>
  </div>
</div>

<script>
/*
  Arena Defender — top-down arena shooter
  Features:
   - WASD/arrow movement, mouse aim, click to shoot (hold to auto-fire).
   - Enemies spawn in waves, increase difficulty.
   - Score / coins for kills; shop to buy upgrades.
   - Simple WebAudio sounds for shooting / hit / death.
   - Touch support: on-screen joystick for movement and tap to shoot.
*/

// ------ Setup canvas and input ------
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
let W = canvas.width, H = canvas.height;

// UI refs
const scoreEl = document.getElementById('score');
const coinsEl = document.getElementById('coins');
const waveEl = document.getElementById('wave');
const hpbar = document.getElementById('hpbar');
const startBtn = document.getElementById('startBtn');
const pauseBtn = document.getElementById('pauseBtn');
const hsEl = document.getElementById('hs');
const killsEl = document.getElementById('kills');
const timeEl = document.getElementById('time');
const priceDmg = document.getElementById('priceDmg');
const priceFire = document.getElementById('priceFire');
const priceHeal = document.getElementById('priceHeal');

// shop buttons
const buyDmg = document.getElementById('buyDmg');
const buyFire = document.getElementById('buyFire');
const buyHeal = document.getElementById('buyHeal');

// audio simple synth
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
function playTone(freq, type='sine', time=0.06, vol=0.08){
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = type; o.frequency.value = freq;
  g.gain.value = vol;
  o.connect(g); g.connect(audioCtx.destination);
  o.start();
  g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + time);
  o.stop(audioCtx.currentTime + time + 0.02);
}

// ------ Game variables ------
let keys = {};
let mouse = {x: W/2, y: H/2, down:false};
let lastTime = 0;
let running = false;
let paused = false;

let player = null;
let bullets = [];
let enemies = [];
let particles = [];
let score = 0;
let coins = 0;
let kills = 0;
let highscore = Number(localStorage.getItem('arena_hs') || 0);
hsEl.textContent = highscore;
let wave = 0;
let waveTimer = 0;
let elapsed = 0;

// shop state / prices
let dmgLevel = 1, fireLevel = 1;
let priceD = 50, priceF = 80, priceH = 40;
priceDmg.textContent = priceD; priceFire.textContent = priceF; priceHeal.textContent = priceH;

// ------ Player class ------
function createPlayer(){
  return {
    x: W/2,
    y: H/2,
    r: 16,
    speed: 220, // px per sec
    hp: 100,
    maxHp: 100,
    fireRate: 0.22, // seconds between shots
    lastShot: 0,
    damage: 18,
    autoFire: false
  };
}

// ------ Input handlers ------
window.addEventListener('keydown', e => { keys[e.key.toLowerCase()] = true; });
window.addEventListener('keyup', e => { keys[e.key.toLowerCase()] = false; });

canvas.addEventListener('mousemove', e => {
  const rect = canvas.getBoundingClientRect();
  mouse.x = (e.clientX - rect.left) * (canvas.width/rect.width);
  mouse.y = (e.clientY - rect.top) * (canvas.height/rect.height);
});
canvas.addEventListener('mousedown', e => { mouse.down = true; resumeAudio(); });
canvas.addEventListener('mouseup', e => { mouse.down = false; });

canvas.addEventListener('touchstart', (e) => { resumeAudio(); e.preventDefault(); mouse.down = true; const t = e.touches[0]; let rect = canvas.getBoundingClientRect(); mouse.x = (t.clientX - rect.left)*(canvas.width/rect.width); mouse.y = (t.clientY - rect.top)*(canvas.height/rect.height); }, {passive:false});
canvas.addEventListener('touchmove', (e) => { e.preventDefault(); const t = e.touches[0]; let rect = canvas.getBoundingClientRect(); mouse.x = (t.clientX - rect.left)*(canvas.width/rect.width); mouse.y = (t.clientY - rect.top)*(canvas.height/rect.height); }, {passive:false});
canvas.addEventListener('touchend', (e) => { e.preventDefault(); mouse.down = false; }, {passive:false});

// mobile: simple joystick (optional improvement could be added)

// resume audio when user interacts (required on some browsers)
function resumeAudio(){
  if(audioCtx.state === 'suspended') audioCtx.resume();
}

// ------ Utils ------
function rand(min,max){ return Math.random()*(max-min)+min; }
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

// ------ Bullets, enemies, particles ------
function spawnBullet(x,y,dx,dy,owner='player',damage=10){
  bullets.push({x,y,dx,dy,owner,damage,ttl:2});
  playTone(900 + Math.random()*200, 'sawtooth', 0.06, 0.06);
}

function spawnEnemy(type='grunt'){
  // types: grunt, fast, tank
  let buffer = 30;
  let x = Math.random()<0.5 ? rand(-buffer, -10) : rand(W+10, W+buffer);
  let y = rand(-buffer, H+buffer);
  let speed = 40;
  let hp = 30;
  let size = 14;
  let reward = 8;
  if(type === 'fast'){ speed = 110; hp=18; size=12; reward=6; }
  if(type === 'tank'){ speed = 30; hp=90; size=20; reward=18; }
  enemies.push({x,y,speed,hp,maxHp:hp,size,type,reward});
}

function spawnWave(){
  wave++;
  waveEl.textContent = wave;
  let count = 4 + wave*1.6;
  for(let i=0;i<count;i++){
    const r = Math.random();
    if(r<0.65) spawnEnemy('grunt');
    else if(r<0.9) spawnEnemy('fast');
    else spawnEnemy('tank');
  }
  waveTimer = 0;
}

// particles simple
function spawnParticle(x,y,color,life=0.6){
  particles.push({x,y,dx:rand(-80,80),dy:rand(-80,80),life,age:0,color});
}

// ------ Game loop ------
function resetGame(){
  player = createPlayer();
  bullets = []; enemies = []; particles = [];
  score = 0; coins = 0; kills = 0; wave = 0; waveTimer=0; elapsed=0;
  scoreEl.textContent = score; coinsEl.textContent = coins; killsEl.textContent = kills; waveEl.textContent = wave;
  hpbar.style.width = '100%';
}

function startGame(){
  resetGame();
  spawnWave();
  running = true;
  paused = false;
  lastTime = performance.now();
  requestAnimationFrame(loop);
}

function togglePause(){
  paused = !paused;
  pauseBtn.textContent = paused ? 'Продолжить' : 'Пауза';
}

// main loop
function loop(ts){
  if(!running) return;
  if(paused){ lastTime = ts; requestAnimationFrame(loop); return; }
  const dt = Math.min(0.06, (ts - lastTime)/1000);
  lastTime = ts;
  update(dt);
  render();
  requestAnimationFrame(loop);
}

// update
function update(dt){
  elapsed += dt;
  timeEl.textContent = Math.floor(elapsed) + 's';
  // movement
  let mvx=0,mvy=0;
  if(keys['w']||keys['arrowup']) mvy -= 1;
  if(keys['s']||keys['arrowdown']) mvy += 1;
  if(keys['a']||keys['arrowleft']) mvx -= 1;
  if(keys['d']||keys['arrowright']) mvx += 1;
  const mm = Math.hypot(mvx,mvy) || 1;
  player.x += (mvx/mm) * player.speed * dt;
  player.y += (mvy/mm) * player.speed * dt;
  player.x = clamp(player.x, 8, W-8);
  player.y = clamp(player.y, 8, H-8);

  // shooting
  player.lastShot += dt;
  const canShoot = player.lastShot >= player.fireRate;
  if((mouse.down || player.autoFire) && canShoot){
    // aim vector
    const ang = Math.atan2(mouse.y - player.y, mouse.x - player.x);
    const spd = 560;
    const dx = Math.cos(ang)*spd;
    const dy = Math.sin(ang)*spd;
    // multi-shot for higher levels (simple spread)
    const shots = dmgLevel >= 4 ? 3 : 1;
    for(let s=0;s<shots;s++){
      const spread = (s - (shots-1)/2) * 0.08;
      const sx = Math.cos(ang+spread)*spd;
      const sy = Math.sin(ang+spread)*spd;
      spawnBullet(player.x + Math.cos(ang)*20, player.y + Math.sin(ang)*20, sx, sy, 'player', player.damage);
    }
    player.lastShot = 0;
  }

  // bullets
  for(let i = bullets.length -1; i>=0; i--){
    const b = bullets[i];
    b.x += b.dx * dt; b.y += b.dy * dt; b.ttl -= dt;
    if(b.ttl <= 0 || b.x < -20 || b.x > W+20 || b.y < -20 || b.y > H+20) bullets.splice(i,1);
  }

  // enemies AI
  for(let i = enemies.length-1; i>=0; i--){
    const e = enemies[i];
    // move toward player
    const dx = player.x - e.x, dy = player.y - e.y;
    const dist = Math.hypot(dx,dy) || 1;
    e.x += (dx/dist) * e.speed * dt;
    e.y += (dy/dist) * e.speed * dt;

    // collision with player
    if(dist < e.size + player.r){
      // damage player
      player.hp -= 12 * dt; // damage per second while touching
      spawnParticle(player.x + rand(-8,8), player.y + rand(-8,8), '--danger');
      if(player.hp <= 0){
        endGame();
        return;
      }
    }
  }

  // bullets vs enemies
  for(let i = enemies.length-1; i>=0; i--){
    const e = enemies[i];
    for(let j = bullets.length-1; j>=0; j--){
      const b = bullets[j];
      if(b.owner === 'player'){
        const dx = e.x - b.x, dy = e.y - b.y;
        if(Math.hypot(dx,dy) < e.size + 6){
          e.hp -= b.damage;
          bullets.splice(j,1);
          spawnParticle(b.x, b.y, '#fff', 0.25);
          playTone(400 + Math.random()*200, 'triangle', 0.04, 0.04);
          if(e.hp <= 0){
            // enemy death
            playTone(120 + Math.random()*120, 'sine', 0.12, 0.08);
            score += e.reward;
            coins += e.reward;
            kills++;
            scoreEl.textContent = score;
            coinsEl.textContent = coins;
            killsEl.textContent = kills;
            // particles explosion
            for(let k=0;k<8;k++) spawnParticle(e.x, e.y, '#f55', 0.8);
            enemies.splice(i,1);
            break;
          }
        }
      }
    }
  }

  // particles update
  for(let i = particles.length-1;i>=0;i--){
    const p = particles[i];
    p.age += dt;
    p.x += p.dx * dt; p.y += p.dy * dt;
    if(p.age > p.life) particles.splice(i,1);
  }

  // wave spawn timer: spawn next wave when enemies empty after a small delay
  if(enemies.length === 0){
    waveTimer += dt;
    if(waveTimer > 1.0){
      spawnWave();
    }
  }

  // regenerate small hp slowly
  player.hp = clamp(player.hp + 2*dt, 0, player.maxHp);
  hpbar.style.width = Math.floor((player.hp/player.maxHp)*100) + '%';

  // update highscore
  if(score > highscore){ highscore = score; localStorage.setItem('arena_hs', highscore); hsEl.textContent = highscore; }

  // auto level up costs shown dynamic (not required)
}

// render
function render(){
  // clear
  ctx.clearRect(0,0,W,H);
  // background grid
  ctx.fillStyle = '#07111a';
  ctx.fillRect(0,0,W,H);
  // subtle grid
  ctx.strokeStyle = 'rgba(255,255,255,0.02)';
  ctx.lineWidth = 1;
  for(let x=0;x<W;x+=40){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke(); }
  for(let y=0;y<H;y+=40){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke(); }

  // particles
  particles.forEach(p => {
    const alpha = 1 - (p.age / p.life);
    ctx.fillStyle = p.color || `rgba(255,255,255,${alpha})`;
    ctx.beginPath(); ctx.arc(p.x, p.y, 3.2*(1-alpha), 0, Math.PI*2); ctx.fill();
  });

  // enemies
  enemies.forEach(e => {
    // body
    ctx.fillStyle = '#ff6b6b';
    if(e.type === 'fast') ctx.fillStyle = '#ffa94d';
    if(e.type === 'tank') ctx.fillStyle = '#f06595';
    ctx.beginPath(); ctx.arc(e.x, e.y, e.size, 0, Math.PI*2); ctx.fill();
    // hp bar
    ctx.fillStyle = 'rgba(0,0,0,0.6)';
    ctx.fillRect(e.x - e.size, e.y - e.size - 8, e.size*2, 5);
    ctx.fillStyle = '#1de9b6';
    ctx.fillRect(e.x - e.size, e.y - e.size - 8, (e.hp/e.maxHp) * e.size*2, 5);
  });

  // bullets
  bullets.forEach(b => {
    ctx.fillStyle = '#ffe66d';
    ctx.beginPath(); ctx.arc(b.x, b.y, 4, 0, Math.PI*2); ctx.fill();
  });

  // player
  ctx.save();
  ctx.translate(player.x, player.y);
  const ang = Math.atan2(mouse.y - player.y, mouse.x - player.x);
  ctx.rotate(ang);
  // body
  const g = ctx.createLinearGradient(-player.r, -player.r, player.r, player.r);
  g.addColorStop(0,'#4dd0e1'); g.addColorStop(1,'#14b8a6');
  ctx.fillStyle = g;
  ctx.beginPath(); ctx.arc(0,0,player.r,0,Math.PI*2); ctx.fill();
  // muzzle
  ctx.fillStyle = '#fff';
  ctx.fillRect(player.r-2, -4, 10, 8);
  ctx.restore();

  // HUD crosshair
  ctx.strokeStyle = 'rgba(255,255,255,0.8)';
  ctx.beginPath(); ctx.moveTo(mouse.x-8, mouse.y); ctx.lineTo(mouse.x+8, mouse.y); ctx.moveTo(mouse.x, mouse.y-8); ctx.lineTo(mouse.x, mouse.y+8); ctx.stroke();
  ctx.beginPath(); ctx.arc(mouse.x, mouse.y, 8, 0, Math.PI*2); ctx.stroke();

  // bottom-left stats small
  ctx.fillStyle = 'rgba(255,255,255,0.06)';
  ctx.fillRect(12, H-62, 220, 50);
  ctx.fillStyle = '#fff';
  ctx.font = '14px Inter, Arial';
  ctx.fillText('HP: ' + Math.floor(player.hp) + '/' + player.maxHp, 20, H-40);
  ctx.fillText('Score: ' + score + '  Kills: ' + kills, 20, H-22);
}

// end game
function endGame(){
  running = false;
  // show simple overlay with result
  setTimeout(()=> {
    const msg = `Ты погиб! Очки: ${score}, Убийств: ${kills}. Нажми "Старт" чтобы сыграть снова.`;
    alert(msg);
  }, 10);
}

// ------ Shop actions ------
buyDmg.addEventListener('click', () => {
  if(coins < priceD) return alert('Недостаточно очков');
  coins -= priceD; coinsEl.textContent = coins;
  dmgLevel++;
  player.damage = Math.round(player.damage * 1.18);
  priceD = Math.round(priceD * 1.5); priceDmg.textContent = priceD;
});

buyFire.addEventListener('click', () => {
  if(coins < priceF) return alert('Недостаточно очков');
  coins -= priceF; coinsEl.textContent = coins;
  fireLevel++;
  player.fireRate = Math.max(0.06, player.fireRate - 0.04);
  priceF = Math.round(priceF * 1.6); priceFire.textContent = priceF;
});

buyHeal.addEventListener('click', () => {
  if(coins < priceH) return alert('Недостаточно очков');
  coins -= priceH; coinsEl.textContent = coins;
  player.hp = Math.min(player.maxHp, player.hp + 20);
});

// start/pause buttons
startBtn.addEventListener('click', () => {
  resumeAudio();
  startGame();
});
pauseBtn.addEventListener('click', () => {
  togglePause();
});

// small auto wave spawner if you survive
// already implemented in update() -> spawnWave()

// start paused (user clicks start)
resetGame();

// responsiveness: scale canvas to fit width while keeping aspect
function fitCanvas(){
  const maxW = window.innerWidth - 360;
  const maxH = window.innerHeight - 40;
  let scale = 1;
  if(window.innerWidth < 980) scale = Math.min((window.innerWidth - 40)/960, (window.innerHeight - 40)/640);
  canvas.style.width = Math.round(960*scale) + 'px';
  canvas.style.height = Math.round(640*scale) + 'px';
}
window.addEventListener('resize', fitCanvas);
fitCanvas();

</script>
</body>
</html>

